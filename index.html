<html ng-app="gpxmod">
  <head>
    <title>GPXmod</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css"
                           integrity="sha512-07I2e+7D8p6he1SIM+1twR5TIrhUQn9+I6yjqD53JQjFiMf8EtC93ty0/5vJTZGF8aAocvHYNEDJajGdNx1IsQ=="
                           crossorigin=""/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
                           integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
                           crossorigin="anonymous"/>
    <script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"
            integrity="sha512-A7vV8IFfih/D732iSSKi20u/ooOfj/AGehOKq0f4vLT1Zr2Y+RX7C+w8A1gaSasGtRUZpF/NZgzSAu4/Gc41Lg=="
            crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.3.1/gpx.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js"></script>

<style>
#mapid { height: 100%; }
</style>

<script>
var app = angular.module('gpxmod', []);

function downloadXml(filename, data) {
  var blob = new Blob([data], {type: 'text/xml'});
  if(window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, filename);
  }
  else{
    var elem = window.document.createElement('a');
    elem.href = window.URL.createObjectURL(blob);
    elem.download = filename;        
    document.body.appendChild(elem);
    elem.click();        
    document.body.removeChild(elem);
    window.URL.revokeObjectURL(elem.href);
  }
}

app.controller('TrackController', function($scope) {
  var color_palette = ['red', 'blue', 'green', 'yellow', 'magenta', 'cyan'];
  $scope.color_palette = color_palette;

  var trackLayers = {};
  var trackPosMarker = L.circleMarker([0, 0], { radius: 7 });

  var map = L.map('mapid').setView([0, 0], 2);
  L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Map data &copy; 2013 OpenStreetMap contributors'
      }).addTo(map);

  // No localStorage for now...
  //function loadFromStorage(key, defaultValue) {
  //  var value = localStorage.getItem('gpxmod-tracks');
  //  return (value && JSON.parse(value)) || defaultValue;
  //}

  //$scope.tracks = loadFromStorage('gpxmod-tracks', []);
  $scope.tracks = [];

  function findClosestPoint(ps, p) {
    var closestIndex = -1;
    var closestPoint = null;
    var closestDistance = Infinity;
    for(var i = 0; i < ps.length; i++) {
      var distance = ps[i].distanceTo(p);
      if(distance < closestDistance) {
        closestIndex = i;
        closestPoint = ps[i];
        closestDistance = distance;
      }
    }

    return {
      index: closestIndex,
      latlng: closestPoint,
    };
  }

  $scope.$watchCollection('selection', function(newSelection, oldSelection) {
    if(newSelection && newSelection.point.latlng) {
      trackPosMarker.setLatLng(newSelection.point.latlng).setStyle({color: trackLayers[newSelection.track.index].options.color}).addTo(map);
      $scope.selectedPointIndex = newSelection.point.index;
    }
  });

  $scope.$watch('selectedPointIndex', function(newIndex, oldIndex) {
    if(newIndex !== undefined && $scope.selection) {
      var newLatLng = trackLayers[$scope.selection.track.index].getLatLngs()[newIndex];
      $scope.selection.point = {
        index: newIndex,
        latlng: newLatLng
      };
    }
  });

  $scope.addTrackToMap = function(track, focusTrack, selectedPointIndex) {
    var g = new L.GPX(track.gpx, {
      async: true,
      marker_options: {
        startIconUrl: null,
        endIconUrl: null
      },
      polyline_options: {
        color: color_palette[track.index % color_palette.length]
      }
    }).on('loaded', function(e) {
      if(e.target.getLayers().length > 1) {
        alert('oops, that gpx file has more than one sub track or some waypoints or something. not sure i can handle that in this alpha stage...'); 
      }
      track.distance = e.target.get_distance();
      if(trackLayers[track.index]) {
        map.removeLayer(trackLayers[track.index]);
      }
      trackLayers[track.index] = e.target.getLayers()[0];
      if(focusTrack) {
        map.fitBounds(e.target.getBounds());
      }
      if(selectedPointIndex !== null) {
        $scope.selectedPointIndex = selectedPointIndex;
      }
      $scope.$digest();
    }).addTo(map)
    .on('click', function(e) {
      var point = findClosestPoint(e.layer.getLatLngs(), e.latlng);
      $scope.selection = {
        track: track,
        point: point
      };
      $scope.$digest();
    });
  };

  for(var i = 0; i < $scope.tracks.length; i++) {
    $scope.addTrackToMap($scope.tracks[i], true, null);
  }

  $scope.newGpxTrackLoaded = function(filename, filecontent) {
    var newTrack = {
      name: filename,
      gpx: filecontent,
      index: $scope.tracks.length
    };

    $scope.addTrackToMap(newTrack, true, null);

    $scope.tracks.push(newTrack);
    //localStorage.setItem('gpxmod-tracks', JSON.stringify($scope.tracks));

    $scope.$digest();
  };

  $scope.trimTrack = function(where) {
    var parser = new DOMParser();

    var doc = parser.parseFromString($scope.selection.track.gpx, 'text/xml');
    var trkseg = doc.getElementsByTagName('trkseg')[0];

    if(where === 'before') {
      for(var i = 0; i < $scope.selection.point.index; i++) {
        trkseg.removeChild(trkseg.children[0]);
      }
      $scope.selectedPointIndex = -1;
      $scope.selection.track.gpx = new XMLSerializer().serializeToString(doc);
      $scope.addTrackToMap($scope.selection.track, false, 0);
    } else if(where === 'after') {
      var lenBefore = trkseg.children.length;
      for(var i = $scope.selection.point.index + 1; i < lenBefore; i++) {
        trkseg.removeChild(trkseg.children[$scope.selection.point.index + 1]);
      }
      $scope.selection.track.gpx = new XMLSerializer().serializeToString(doc);
      $scope.addTrackToMap($scope.selection.track, false, $scope.selectedPointIndex);
      $scope.selectedPointIndex = -1;
    } else {
      console.log('where must be either before or after, was ' + where);
      return;
    }
  };

  $scope.flipTrack = function() {
    var parser = new DOMParser();
    doc = parser.parseFromString($scope.selection.track.gpx, 'text/xml');
    var trkseg = doc.getElementsByTagName('trkseg')[0];

    var buffer = [];
    while(trkseg.children.length > 0) {
      buffer.push(trkseg.removeChild(trkseg.children[0]));
    }

    for(var i = buffer.length - 1; i >= 0; i--) {
      trkseg.appendChild(buffer[i]);
    }

    var newSelectionIndex = buffer.length - 1 - $scope.selection.point.index;
    $scope.selectedPointIndex = -1;
    $scope.selection.track.gpx = new XMLSerializer().serializeToString(doc);
    $scope.addTrackToMap($scope.selection.track, false, newSelectionIndex);
  };

  $scope.mergeTrack = function(direction, other) {
    var parser = new DOMParser();

    var doc = parser.parseFromString($scope.selection.track.gpx, 'text/xml');
    var trkseg = doc.getElementsByTagName('trkseg')[0];

    var trksegOther = parser.parseFromString(other.gpx, 'text/xml').getElementsByTagName('trkseg')[0];

    if(direction === 'prepend') {
      console.log('not implemented yet');
    } else if(direction === 'append') {
      for(var i = 0; i < trksegOther.children.length; i++) {
        trkseg.appendChild(trksegOther.children[i].cloneNode(true));
      }
    } else {
      console.log('direction must be either prepend or append, was ' + where);
      return;
    }

    var selectionIndex = $scope.selection.point.index;
    $scope.selectedPointIndex = -1;
    $scope.selection.track.name = 'merged.gpx';
    $scope.selection.track.gpx = new XMLSerializer().serializeToString(doc);
    $scope.addTrackToMap($scope.selection.track, false, selectionIndex);
  };

  $scope.downloadTrack = function(track) {
    downloadXml(track.name, track.gpx);
  };
});

app.directive("gpxTrackUpload",function(){    
  return {
    restrict: 'A',
    link: function($scope,el){          
      el.bind("change", function(evt){          
        if(!window.FileReader) return; // Browser is not compatible

        var reader = new FileReader();

        var file = evt.target.files[0];

        reader.onload = function(evt) {
          if(evt.target.readyState != 2) return;
          if(evt.target.error) {
            alert('Error while reading file');
            return;
          }

          filecontent = evt.target.result;

          $scope.newGpxTrackLoaded(file.name, filecontent);
        }

        reader.readAsText(file);
      });          
    }        
  }
});
</script>
  </head>
  <body ng-controller="TrackController">
    <div class="container-fluid">
      <div class="row">
        <div class="col-md-3">
          <h1>GPXmod</h1>

          <p class="help-block">
            Add GPX tracks by selecting files below.
          </p>

          <form id="myform">
            <p>
            <input type="file" gpx-track-upload/>
            </p>
          </form>

          <ul class="list-unstyled">
            <li ng-repeat="track in tracks track by track.name">
              <span class="glyphicon glyphicon-minus" style="color: {{color_palette[track.index % color_palette.length]}};"></span>
              {{track.name}}
              <span ng-show="track.distance">- {{track.distance | number: 2}} m</span>
              <!-- <button type="button" class="btn btn-link btn-xs">
                <span class="glyphicon glyphicon-trash"></span>
              </button> -->
              <button type="button" class="btn btn-link btn-xs" ng-click="downloadTrack(track)">
                <span class="glyphicon glyphicon-save"></span>
              </button>
            </li>
          </ul>

          <h2>Editing</h2>
          <p class="help-block" ng-hide="selection">
            Click on a track on the map to select it.
          </p>
          <div ng-show="selection">
            <div>
              <span class="glyphicon glyphicon-minus" ng-style="{'color': color_palette[selection.track.index % color_palette.length]}"></span>
              <small>{{selection.track.name}}</small>
            </div>

            <form class="form form-inline">
              <div class="row">
                <div class="col-md-12">
                  <input class="form-control" type="number" ng-model="selectedPointIndex"/>
                  {{selection.point.latlng}}
                </div>
              </div>
            </form>
            <button class="btn btn-default" ng-click="trimTrack('before')">Trim Before</button>
            <button class="btn btn-default" ng-click="trimTrack('after')">Trim After</button>
            <button class="btn btn-default" ng-click="flipTrack()">Flip Track</button>

            <h4>Merge tracks</h4>

            <ul class="list-unstyled">
              <li ng-repeat="track in tracks | filter: { index: '!' + selection.track.index } track by track.name">
                <span class="glyphicon glyphicon-minus" style="color: {{color_palette[track.index % color_palette.length]}};"></span>
                {{track.name}}
                <button class="btn btn-default btn-xs" ng-click="mergeTrack('prepend', track)">Prepend</button>
                <button class="btn btn-default btn-xs" ng-click="mergeTrack('append', track)">Append</button>
              </li>
            </ul>
          </div>
        </div>
        <div class="col-md-9">
          <div id="mapid"></div>
        </div>
      </div>
    </div>
  </body>
</html>
